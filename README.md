# Example demonstrating combining of readline and ncurses

## Features

Supports seamless and efficient terminal resizing and multibyte/combining/wide characters. (Wide characters are those that use more than one terminal column.)

One of the trickier aspects is that readline only exports the cursor position as a byte offset (`rl_point`), which won't correspond to the correct terminal cursor column for many strings with special characters. We therefore have to calculate the terminal cursor column ourselves. readline itself does it as part of the default `rl_redisplay()` function.

## Limitations

* Some invalid strings and meta characters could still cause the cursor position to be off (though it's only a visual annoyance).

* Entering multibyte characters during search (e.g., **Ctrl-R**) does not work, due to [a readline issue]( http://lists.gnu.org/archive/html/bug-readline/2015-02/msg00026.html). The only workaround I've found is to let readline directly from stdin instead (e.g., via a `select(2)` loop). Buffering bytes until they form a complete multibyte character (e.g., via `get_wch()` + `wcrtomb()`) doesn't help either.

  A neat setup on Linux is to use `signalfd(2)` ([libevent](http://libevent.org) might be a portable option) to catch the `SIGWINCH` generated by the terminal resize in the `select(2)` (or `epoll(7)`) loop and then calling `resizeterm()` and updating the windows (the manual `resizeterm()` is needed since we override ncurses' default `SIGWINCH` handler). I have a WIP that uses that approach in a branch for [another project](https://github.com/ulfalizer/botniklas). I could push it on request.
 
* To keep things simple, the readline (bottom) window does not scroll. It would require some care to get special characters right.

## Screenshot

![screenshot](https://raw.githubusercontent.com/ulfalizer/readline-and-ncurses/screenshot/screenshot.png)

The contents of the top window is set to whatever is entered. To exit, press **Ctrl-D** on an empty line.
